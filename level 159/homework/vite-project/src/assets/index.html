<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // -----------------------------
// რა არის კომპონენტი (Component) — დეტალურად
// -----------------------------
// კომპონენტი არის UI-ის (`user interface`) დამოუკიდებელი, ხელახლა
// გამოყენებადი ნაწილი. მაგალითად: ღილაკი, სათაური, მომხმარებლის ბარათი,
// ან მთელი გვერდის სექცია შეიძლება იყოს კომპონენტი.
// კომპონენტებს ვაკეთებთ იმისთვის, რომ UI ჩავყოთ პატარა, მარტივად
// გასაგებ და გადაამუშავებელ ცალკეულ ნაწილებად.

// კომპონენტები განსაზღვრავენ:
// - რა უნდა გამოჩნდეს (HTML/JSX).
// - შესაძლოა ჰქონდეთ შინაგანი მდგომარეობა (state).
// - იღებენ გარედან მონაცემებს (props).
// - შეუძლიათ რეაგირება ექსპრესიებზე (events) — კლიკები, ფორმები და ა.შ.

// -----------------------------
// რამდენი ტიპის კომპონენტია (ზოგადი კატეგორიები)
// -----------------------------
// 1) Functional Components (ფუნქციური კომპონენტები)
//    - ჩვეულებრივი JavaScript ფუნქციებია, რომლებიც მიღებულ props-ს
//      აკონვერტირებენ UI-ად (JSX).
//    - თანამედროვე React-ში უმეტესობა ფუნქციურია და იყენებს Hooks-ს
//      (useState, useEffect და ა.შ.).
//
// 2) Class Components (კლასური კომპონენტები)
//    - ES6 კლასების გამოყენებით იქმნება და აქვთ lifecycle მეთოდები
//      (componentDidMount, componentDidUpdate და ა.შ.).
//    - წინა წლებში გავრცელებული იყო, დღეს კი ფუნქციური კომპონენტები
//      ხშირად ფავორიტია Hooks-ის გამო.
//
// 3) Pure Components / Memoized Components
//    - კომპონენტი, რომელიც არ ეთიშება რენდერს თუ props-ები არ შეიცვალა.
//    - React.memo ან PureComponent გამოიყენება არაუმეტეს მოხმარებისთვის
//      შესრულების გაუმჯობესების მიზნით.
//
// 4) Presentational vs Container (შესაძლებლობები)
//    - Presentational (პრეზენტაციული): მხოლოდ ვიზუალურ ნაწილზეა პასუხიმგებელი,
//      არ ინახავს მნიშვნელოვან ლოგიკას, იღებს props-ებს და აჩვენებს.
//    - Container (კონტეინერი): ანგარიშს ატარებს ლოგიკასა და state-ს,
//      გადაეცემს მონაცემებს პრეზენტაციულ კომპონენტებს.
//
// 5) Higher-Order Components (HOC)
//    - ფუნქცია, რომელიც ერთ კომპონენტს იღებს და ახალ კომპონენტს აბრუნებს,
//      მაგალითად: withAuth(MyComponent).
//
// 6) Render Props და Compound Components
//    - Render props: კომპონენტი იღებს ფუნქციას prop-ად, რომელიც განსაზღვრავს
//      როგორ უნდა დამუშავდა UI-ის ნაწილი.
//    - Compound components: რამდენიმე პატარა კომპონენტი ერთად მუშაობს,
//      როგორც ერთიანი კომპონენტური API (მაგ., Tabs + TabList + TabPanel).
//
// 7) Controlled vs Uncontrolled Components (ფორმების კონტექსტში)
//    - Controlled: კომპონენტის value კონტროლდება parent-ის state-ით.
//    - Uncontrolled: გამოიყენება DOM reference-ები (ref) და დამოუკიდებლად იკვებება.

// -----------------------------
// მცირე მაგალითები (კომენტარებით ახსნებით)
// -----------------------------

// Functional component (მოდერნი, Hooks-ით)
// function Button({ label, onClick }) {
//   // ეს კომპონენტი იღებს props-ებს და აბრუნებს JSX-პერსონას.
//   // არ ინახავს რაიმე რთულ მდგომარეობას (მაგრამ შეიძლებოდა ვიქნებნა useState).
//   return <button onClick={onClick}>{label}</button>;
// }

// Class component (ბიოწარსულიდან)
// class Counter extends React.Component {
//   // კლასური კომპონენტის დაწყებითი მდგომარეობა
//   state = { count: 0 };
//
//   componentDidMount() {
//     // ლიფცაიქლის მაგალითი — კომპონენტი mount-ბდას ბოლოში.
//   }
//
//   render() {
//     return (
//       <div>
//         <p>Count: {this.state.count}</p>
//         <button onClick={() => this.setState({ count: this.state.count + 1 })}>
//           +1
//         </button>
//       </div>
//     );
//   }
// }

// Higher-Order Component (HOC) — კონცეფცია
// function withLogger(WrappedComponent) {
//   // აბრუნებს ახალ კომპონენტს, რომელიც ლოგებს გადამცემს.
//   return function(props) {
//     console.log('Props:', props);
//     return <WrappedComponent {...props} />;
//   };
// }

// -----------------------------
// კომპონენტების უპირატესობები (Advantages)
// -----------------------------
// 1) რეიუზაბილობა (Reusability):
//    - ერთ კომპონენტს ბევრ ადგილზე შეგიძლია გამოიყენო, რაც ამცირებს დუპლიკაციას.
//
// 2) მარტივი რეფაქტორინგი და შენახვისა/მშენებლობის გამარტივება:
//    - პატარა, ლოგიკურად განცალკევებული ნაწილები ადვილად წაიშლება ან შეიცვლება.
//
// 3) მარტივი ტესტირება (Testability):
//    - მცირე, დამოუკიდებელი კომპონენტები მარტივად იტესტება ერთეულურად.
//
// 4) Separation of concerns (ნაწილის და პრობლემის განცალკევება):
//    - UI-ს ლოგიკა, პრეზენტაცია და მონაცემთა მისაღები ნაწილი შეიძლება
//      განცალკევდეს ერთმანეთისგან (container vs presentational).
//
// 5) ეფექტური მუშაობა და ოპტიმიზაციები:
//    - React.memo, PureComponent, shouldComponentUpdate და სხვები ეხმარება
//      გაუმჯობესონ UI-ს შესრულება ( ნაკლები ზედმეტი რენდერი ).
//
// 6) დამოკიდებულებების გამარტივება და readability:
//    - კოდი ხდება უფრო მკითხველი და ორგანიზებული.

// -----------------------------
// საუკეთესო პრაქტიკები (Best practices)
// -----------------------------
// - გააკეთე კომპონენტები პატარა და Single Responsibility-ით (ერთი ფუნქცია).
// - გამოიყენე descriptive სახელები (UserCard, LoginForm), ახსნილი props.
// - ნუ დაადნობ ფუნქციონალობას ძალიან ღრმა მიერეკვენს (deep prop drilling) —
//   გამოიყენე Context ან state management თუ საჭიროა.
// - გამოიყენე memoization (React.memo, useMemo, useCallback) სადაც მართებულია,
//   მაგრამ ნუ წინასწარ ოპტიმიზირებ (premature optimization).
// - აშენე კომბინაციები: პატარა components => compose => დიდი UI ნაწილი.
// - დაწერე ტესტები უსაფუძვლოდ (unit tests, snapshot tests) ძირითად კომპონენტებზე.
//
// -----------------------------
// რეზიუმე
// -----------------------------
// კომპონენტები — UI-ის ძირითადი ბლოკებია. შენ იყენებ სხვადასხვა ტიპის
// კომპონენტებს (Functional, Class, Pure, HOC, და სხვ.) იმავე მიზნისათვის:
// UI-ს მოდულარიზაცია, რეიუზაბილობა, და უკეთესი შენარჩუნებობა.
// კარგი კომპონენტური არქიტექტურა ძალიან აადვილებს აპლიკაციის ზრდასა და
// ტექნიკურ მოვლა-პირობას.

    </script>
</body>
</html>